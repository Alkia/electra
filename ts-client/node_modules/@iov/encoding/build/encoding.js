"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const base64js = __importStar(require("base64-js"));
const readonly_date_1 = require("readonly-date");
class Encoding {
    static toHex(data) {
        let out = "";
        for (const byte of data) {
            out += ("0" + byte.toString(16)).slice(-2);
        }
        return out;
    }
    static fromHex(hexstring) {
        if (hexstring.length % 2 !== 0) {
            throw new Error("hex string length must be a multiple of 2");
        }
        // tslint:disable-next-line:readonly-array
        const listOfInts = [];
        for (let i = 0; i < hexstring.length; i += 2) {
            const hexByteAsString = hexstring.substr(i, 2);
            if (!hexByteAsString.match(/[0-9a-f]{2}/i)) {
                throw new Error("hex string contains invalid characters");
            }
            listOfInts.push(parseInt(hexByteAsString, 16));
        }
        return new Uint8Array(listOfInts);
    }
    static toBase64(data) {
        return base64js.fromByteArray(data);
    }
    static fromBase64(base64String) {
        if (!base64String.match(/^[a-zA-Z0-9+/]*={0,2}$/)) {
            throw new Error("Invalid base64 string format");
        }
        return base64js.toByteArray(base64String);
    }
    static toAscii(input) {
        const toNums = (str) => str.split("").map((x) => {
            const charCode = x.charCodeAt(0);
            // 0x00–0x1F control characters
            // 0x20–0x7E printable characters
            // 0x7F delete character
            // 0x80–0xFF out of 7 bit ascii range
            if (charCode < 0x20 || charCode > 0x7e) {
                throw new Error("Cannot encode character that is out of printable ASCII range: " + charCode);
            }
            return charCode;
        });
        return Uint8Array.from(toNums(input));
    }
    static fromAscii(data) {
        const fromNums = (listOfNumbers) => listOfNumbers.map((x) => {
            // 0x00–0x1F control characters
            // 0x20–0x7E printable characters
            // 0x7F delete character
            // 0x80–0xFF out of 7 bit ascii range
            if (x < 0x20 || x > 0x7e) {
                throw new Error("Cannot decode character that is out of printable ASCII range: " + x);
            }
            return String.fromCharCode(x);
        });
        return fromNums(Array.from(data)).join("");
    }
    static toUtf8(str) {
        // Browser and future nodejs (https://github.com/nodejs/node/issues/20365)
        if (typeof TextEncoder !== "undefined") {
            return new TextEncoder().encode(str);
        }
        // Use Buffer hack instead of nodejs util.TextEncoder to ensure
        // webpack does not bundle the util module for browsers.
        return new Uint8Array(Buffer.from(str, "utf8"));
    }
    static fromUtf8(data) {
        // Browser and future nodejs (https://github.com/nodejs/node/issues/20365)
        if (typeof TextDecoder !== "undefined") {
            return new TextDecoder("utf-8", { fatal: true }).decode(data);
        }
        // Use Buffer hack instead of nodejs util.TextDecoder to ensure
        // webpack does not bundle the util module for browsers.
        // Buffer.toString has no fatal option
        if (!Encoding.isValidUtf8(data)) {
            throw new Error("Invalid UTF8 data");
        }
        return Buffer.from(data).toString("utf8");
    }
    static fromRfc3339(str) {
        const rfc3339Matcher = /^(\d{4})-(\d{2})-(\d{2})[T ](\d{2}):(\d{2}):(\d{2})(\.\d{1,9})?((?:[+-]\d{2}:\d{2})|Z)$/;
        const matches = rfc3339Matcher.exec(str);
        if (!matches) {
            throw new Error("Date string is not in RFC3339 format");
        }
        const year = +matches[1];
        const month = +matches[2];
        const day = +matches[3];
        const hour = +matches[4];
        const minute = +matches[5];
        const second = +matches[6];
        // fractional seconds match either undefined or a string like ".1", ".123456789"
        const milliSeconds = matches[7] ? Math.floor(+matches[7] * 1000) : 0;
        let tzOffsetSign;
        let tzOffsetHours;
        let tzOffsetMinutes;
        // if timezone is undefined, it must be Z or nothing (otherwise the group would have captured).
        if (matches[8] === "Z") {
            tzOffsetSign = 1;
            tzOffsetHours = 0;
            tzOffsetMinutes = 0;
        }
        else {
            tzOffsetSign = matches[8].substring(0, 1) === "-" ? -1 : 1;
            tzOffsetHours = +matches[8].substring(1, 3);
            tzOffsetMinutes = +matches[8].substring(4, 6);
        }
        const tzOffset = tzOffsetSign * (tzOffsetHours * 60 + tzOffsetMinutes) * 60; // seconds
        return new readonly_date_1.ReadonlyDate(readonly_date_1.ReadonlyDate.UTC(year, month - 1, day, hour, minute, second, milliSeconds) - tzOffset * 1000);
    }
    static toRfc3339(date) {
        function padded(integer, length = 2) {
            const filled = "00000" + integer.toString();
            return filled.substring(filled.length - length);
        }
        const year = date.getUTCFullYear();
        const month = padded(date.getUTCMonth() + 1);
        const day = padded(date.getUTCDate());
        const hour = padded(date.getUTCHours());
        const minute = padded(date.getUTCMinutes());
        const second = padded(date.getUTCSeconds());
        const ms = padded(date.getUTCMilliseconds(), 3);
        return `${year}-${month}-${day}T${hour}:${minute}:${second}.${ms}Z`;
    }
    static isValidUtf8(data) {
        const toStringAndBack = Buffer.from(Buffer.from(data).toString("utf8"), "utf8");
        return Buffer.compare(Buffer.from(data), toStringAndBack) === 0;
    }
}
exports.Encoding = Encoding;
//# sourceMappingURL=encoding.js.map