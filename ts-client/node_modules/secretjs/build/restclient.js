"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const encoding_1 = require("@iov/encoding");
const axios_1 = __importDefault(require("axios"));
const enigmautils_1 = __importDefault(require("./enigmautils"));
const ProtoEncoding_1 = require("./ProtoEncoding");
const v1_4_protos_1 = require("./v1.4_protos");
function normalizeArray(backend) {
    return backend || [];
}
/**
 * The mode used to send transaction
 *
 * @see https://cosmos.network/rpc/#/Transactions/post_txs
 */
var BroadcastMode;
(function (BroadcastMode) {
    /** Return after tx commit */
    BroadcastMode["Block"] = "block";
    /** Return afer CheckTx */
    BroadcastMode["Sync"] = "sync";
    /** Return right away */
    BroadcastMode["Async"] = "async";
})(BroadcastMode = exports.BroadcastMode || (exports.BroadcastMode = {}));
function isWasmError(resp) {
    return resp.error !== undefined;
}
function unwrapWasmResponse(response) {
    if (isWasmError(response)) {
        throw new Error(response.error);
    }
    return response.result;
}
// We want to get message data from 500 errors
// https://stackoverflow.com/questions/56577124/how-to-handle-500-error-message-with-axios
// this should be chained to catch one error and throw a more informative one
function parseAxiosError(err) {
    var _a;
    // use the error message sent from server, not default 500 msg
    if ((_a = err.response) === null || _a === void 0 ? void 0 : _a.data) {
        let errorText;
        const data = err.response.data;
        // expect { error: string }, but otherwise dump
        if (data.error && typeof data.error === "string") {
            errorText = data.error;
        }
        else if (typeof data === "string") {
            errorText = data;
        }
        else {
            errorText = JSON.stringify(data);
        }
        throw new Error(`${errorText} (HTTP ${err.response.status})`);
    }
    else {
        throw err;
    }
}
class RestClient {
    /**
     * Creates a new client to interact with a Cosmos SDK light client daemon.
     * This class tries to be a direct mapping onto the API. Some basic decoding and normalizatin is done
     * but things like caching are done at a higher level.
     *
     * When building apps, you should not need to use this class directly. If you do, this indicates a missing feature
     * in higher level components. Feel free to raise an issue in this case.
     *
     * @param apiUrl The URL of a Cosmos SDK light client daemon API (sometimes called REST server or REST API)
     * @param broadcastMode Defines at which point of the transaction processing the postTx method (i.e. transaction broadcasting) returns
     * @param seed - The seed used to generate sender TX encryption key. If empty will generate random new one
     */
    constructor(apiUrl, broadcastMode = BroadcastMode.Block, seed) {
        const headers = {
            post: { "Content-Type": "application/json" },
        };
        this.client = axios_1.default.create({
            baseURL: apiUrl,
            headers: headers,
        });
        this.broadcastMode = broadcastMode;
        this.enigmautils = new enigmautils_1.default(apiUrl, seed);
        this.codeHashCache = new Map();
    }
    async get(path) {
        const { data } = await this.client.get(path).catch(parseAxiosError);
        if (data === null) {
            throw new Error("Received null response from server");
        }
        return data;
    }
    async post(path, params) {
        if (!encoding_1.isNonNullObject(params))
            throw new Error("Got unexpected type of params. Expected object.");
        const { data } = await this.client.post(path, params).catch(parseAxiosError);
        if (data === null) {
            throw new Error("Received null response from server");
        }
        return data;
    }
    // The /auth endpoints
    async authAccounts(address) {
        const [authResp, bankResp] = (await Promise.all([
            this.get(`/auth/accounts/${address}`),
            this.get(`/bank/balances/${address}`),
        ]));
        const result = {
            height: bankResp.height,
            result: {
                type: "cosmos-sdk/Account",
                value: {
                    address: authResp.result.value.address,
                    coins: bankResp.result,
                    public_key: JSON.stringify(authResp.result.value.public_key),
                    account_number: Number(authResp.result.value.account_number || 0),
                    sequence: Number(authResp.result.value.sequence || 0),
                },
            },
        };
        return result;
    }
    // The /blocks endpoints
    async blocksLatest() {
        const responseData = await this.get("/blocks/latest");
        if (!responseData.block) {
            throw new Error("Unexpected response data format");
        }
        return responseData;
    }
    async blocks(height) {
        const responseData = await this.get(`/blocks/${height}`);
        if (!responseData.block) {
            throw new Error("Unexpected response data format");
        }
        return responseData;
    }
    // The /node_info endpoint
    async nodeInfo() {
        const responseData = await this.get("/node_info");
        if (!responseData.node_info) {
            throw new Error("Unexpected response data format");
        }
        return responseData;
    }
    // The /txs endpoints
    async txById(id, tryToDecrypt = true) {
        const responseData = await this.get(`/txs/${id}`);
        if (!responseData.tx) {
            throw new Error("Unexpected response data format");
        }
        if (tryToDecrypt) {
            return this.decryptTxsResponse(responseData);
        }
        else {
            return responseData;
        }
    }
    async txsQuery(query, tryToDecrypt = true) {
        const responseData = await this.get(`/txs?${query}`);
        if (!responseData.txs) {
            throw new Error("Unexpected response data format");
        }
        const resp = responseData;
        if (tryToDecrypt) {
            for (let i = 0; i < resp.txs.length; i++) {
                resp.txs[i] = await this.decryptTxsResponse(resp.txs[i]);
            }
        }
        return resp;
    }
    /** returns the amino-encoding of the transaction performed by the server */
    async encodeTx(tx) {
        const responseData = await this.post("/txs/encode", tx);
        if (!responseData.tx) {
            throw new Error("Unexpected response data format");
        }
        return encoding_1.Encoding.fromBase64(responseData.tx);
    }
    /**
     * Broadcasts a signed transaction to into the transaction pool.
     * Depending on the RestClient's broadcast mode, this might or might
     * wait for checkTx or deliverTx to be executed before returning.
     *
     * @param tx a signed transaction as StdTx (i.e. not wrapped in type/value container)
     */
    async postTx(tx) {
        const params = {
            tx: tx,
            mode: this.broadcastMode,
        };
        const responseData = await this.post("/txs", params);
        if (!responseData.txhash) {
            throw new Error("Unexpected response data format");
        }
        return responseData;
    }
    // The /wasm endpoints
    // wasm rest queries are listed here: https://github.com/cosmwasm/wasmd/blob/master/x/wasm/client/rest/query.go#L19-L27
    async listCodeInfo() {
        const path = `/wasm/code`;
        const responseData = (await this.get(path));
        return normalizeArray(await unwrapWasmResponse(responseData));
    }
    // this will download the original wasm bytecode by code id
    // throws error if no code with this id
    async getCode(id) {
        const path = `/wasm/code/${id}`;
        const responseData = (await this.get(path));
        return await unwrapWasmResponse(responseData);
    }
    async listContractsByCodeId(id) {
        const path = `/wasm/code/${id}/contracts`;
        const responseData = (await this.get(path));
        return normalizeArray(await unwrapWasmResponse(responseData));
    }
    async getCodeHashByCodeId(id) {
        const codeHashFromCache = this.codeHashCache.get(id);
        if (typeof codeHashFromCache === "string") {
            return codeHashFromCache;
        }
        const path = `/wasm/code/${id}/hash`;
        const responseData = (await this.get(path));
        this.codeHashCache.set(id, responseData.result);
        return responseData.result;
    }
    async getCodeHashByContractAddr(addr) {
        const codeHashFromCache = this.codeHashCache.get(addr);
        if (typeof codeHashFromCache === "string") {
            return codeHashFromCache;
        }
        const path = `/wasm/contract/${addr}/code-hash`;
        const responseData = (await this.get(path));
        this.codeHashCache.set(addr, responseData.result);
        return responseData.result;
    }
    /**
     * Returns null when contract was not found at this address.
     */
    async getContractInfo(address) {
        const path = `/wasm/contract/${address}`;
        const response = (await this.get(path));
        return await unwrapWasmResponse(response);
    }
    /**
     * Makes a smart query on the contract and parses the reponse as JSON.
     * Throws error if no such contract exists, the query format is invalid or the response is invalid.
     */
    async queryContractSmart(contractAddress, query, addedParams, contractCodeHash) {
        var _a;
        if (!contractCodeHash) {
            contractCodeHash = await this.getCodeHashByContractAddr(contractAddress);
        }
        else {
            this.codeHashCache.set(contractAddress, contractCodeHash);
        }
        const encrypted = await this.enigmautils.encrypt(contractCodeHash, query);
        const nonce = encrypted.slice(0, 32);
        const encoded = encoding_1.Encoding.toHex(encoding_1.Encoding.toUtf8(encoding_1.Encoding.toBase64(encrypted)));
        // @ts-ignore
        const paramString = new URLSearchParams(addedParams).toString();
        const path = `/wasm/contract/${contractAddress}/query/${encoded}?encoding=hex&${paramString}`;
        let responseData;
        try {
            responseData = (await this.get(path));
        }
        catch (err) {
            try {
                const errorMessageRgx = /encrypted: (.+?): (?:instantiate|execute|query) contract failed \(HTTP 500\)/g;
                // @ts-ignore
                const rgxMatches = errorMessageRgx.exec(err.message);
                if (rgxMatches == null || ((_a = rgxMatches) === null || _a === void 0 ? void 0 : _a.length) != 2) {
                    throw err;
                }
                const errorCipherB64 = rgxMatches[1];
                const errorCipherBz = encoding_1.Encoding.fromBase64(errorCipherB64);
                const errorPlainBz = await this.enigmautils.decrypt(errorCipherBz, nonce);
                //@ts-ignore
                err.message = err.message.replace(errorCipherB64, encoding_1.Encoding.fromUtf8(errorPlainBz));
            }
            catch (decryptionError) {
                //@ts-ignore
                throw new Error(`Failed to decrypt the following error message: ${err.message}.`);
            }
            throw err;
        }
        if (isWasmError(responseData)) {
            throw new Error(JSON.stringify(await this.enigmautils.decrypt(encoding_1.Encoding.fromBase64(responseData.error), nonce)));
        }
        // By convention, smart queries must return a valid JSON document (see https://github.com/CosmWasm/cosmwasm/issues/144)
        return JSON.parse(encoding_1.Encoding.fromUtf8(encoding_1.Encoding.fromBase64(encoding_1.Encoding.fromUtf8(await this.enigmautils.decrypt(encoding_1.Encoding.fromBase64(responseData.result.smart), nonce)))));
    }
    /**
     * Get the consensus keypair for IO encryption
     */
    async getMasterCerts(address, query) {
        return this.get("/register/master-cert");
    }
    async decryptDataField(dataField = "", nonces) {
        const wasmOutputDataCipherBz = encoding_1.Encoding.fromHex(dataField);
        let error;
        for (const nonce of nonces) {
            try {
                const data = encoding_1.Encoding.fromBase64(encoding_1.Encoding.fromUtf8(await this.enigmautils.decrypt(wasmOutputDataCipherBz, nonce)));
                return data;
            }
            catch (e) {
                error = e;
            }
        }
        throw error;
    }
    async decryptLogs(logs, nonces) {
        for (const l of logs) {
            for (const e of l.events) {
                if (e.type === "wasm") {
                    for (const nonce of nonces) {
                        let nonceOk = false;
                        for (const a of e.attributes) {
                            try {
                                a.key = encoding_1.Encoding.fromUtf8(await this.enigmautils.decrypt(encoding_1.Encoding.fromBase64(a.key), nonce));
                                nonceOk = true;
                            }
                            catch (e) { }
                            try {
                                a.value = encoding_1.Encoding.fromUtf8(await this.enigmautils.decrypt(encoding_1.Encoding.fromBase64(a.value), nonce));
                                nonceOk = true;
                            }
                            catch (e) { }
                        }
                        if (nonceOk) {
                            continue;
                        }
                    }
                }
            }
        }
        return logs;
    }
    async decryptTxsResponse(txsResponse) {
        var _a, _b, _c;
        let dataFields;
        let data = Uint8Array.from([]);
        if (txsResponse.data) {
            dataFields = ProtoEncoding_1.decodeTxData(encoding_1.Encoding.fromHex(txsResponse.data));
        }
        let logs = txsResponse.logs;
        if (logs) {
            logs[0].msg_index = 0;
        }
        for (let i = 0; i < ((_a = txsResponse.tx.value.msg) === null || _a === void 0 ? void 0 : _a.length); i++) {
            const msg = txsResponse.tx.value.msg[i];
            let inputMsgEncrypted;
            if (msg.type === "wasm/MsgExecuteContract") {
                inputMsgEncrypted = encoding_1.Encoding.fromBase64(msg.value.msg);
            }
            else if (msg.type === "wasm/MsgInstantiateContract") {
                inputMsgEncrypted = encoding_1.Encoding.fromBase64(msg.value.init_msg);
            }
            else {
                continue;
            }
            const inputMsgPubkey = inputMsgEncrypted.slice(32, 64);
            if (encoding_1.Encoding.toBase64(await this.enigmautils.getPubkey()) === encoding_1.Encoding.toBase64(inputMsgPubkey)) {
                // my pubkey, can decrypt
                const nonce = inputMsgEncrypted.slice(0, 32);
                // decrypt input
                const inputMsg = encoding_1.Encoding.fromUtf8(await this.enigmautils.decrypt(inputMsgEncrypted.slice(64), nonce));
                if (msg.type === "wasm/MsgExecuteContract") {
                    // decrypt input
                    txsResponse.tx.value.msg[i].value.msg = inputMsg;
                    // decrypt output data
                    // stupid workaround because only 1st message data is returned
                    if (dataFields && i == 0 && dataFields[0].data) {
                        const decoded = v1_4_protos_1.MsgExecuteContractResponse.decode(encoding_1.Encoding.fromBase64(dataFields[0].data));
                        data = await this.decryptDataField(encoding_1.Encoding.toHex(decoded.data), [nonce]);
                    }
                }
                else if (msg.type === "wasm/MsgInstantiateContract") {
                    // decrypt input
                    txsResponse.tx.value.msg[i].value.init_msg = inputMsg;
                }
                // decrypt output logs
                if (txsResponse.logs && logs) {
                    if (!((_b = txsResponse.logs[i]) === null || _b === void 0 ? void 0 : _b.log)) {
                        logs[i].log = "";
                    }
                    logs[i] = (await this.decryptLogs([txsResponse.logs[i]], [nonce]))[0];
                }
                // failed to execute message; message index: 0: encrypted: (.+?): (?:instantiate|execute|query) contract failed
                // decrypt error
                const errorMessageRgx = new RegExp(`failed to execute message; message index: ${i}:(?: dispatch: submessages:)* encrypted: (.+?): (?:instantiate|execute|query) contract failed`, "g");
                const rgxMatches = errorMessageRgx.exec(txsResponse.raw_log);
                if (Array.isArray(rgxMatches) && ((_c = rgxMatches) === null || _c === void 0 ? void 0 : _c.length) === 2) {
                    const errorCipherB64 = rgxMatches[1];
                    const errorCipherBz = encoding_1.Encoding.fromBase64(errorCipherB64);
                    const errorPlainBz = await this.enigmautils.decrypt(errorCipherBz, nonce);
                    txsResponse.raw_log = txsResponse.raw_log.replace(errorCipherB64, encoding_1.Encoding.fromUtf8(errorPlainBz));
                }
            }
        }
        txsResponse = Object.assign({}, txsResponse, { logs: logs });
        // @ts-ignore
        txsResponse.data = data;
        return txsResponse;
    }
}
exports.RestClient = RestClient;
//# sourceMappingURL=restclient.js.map